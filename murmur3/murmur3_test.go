// Copyright 2012 Apcera, Inc. All rights reserved.

package murmur3

import (
	"testing"
)

// Tests Murmur3 to ensure it works with changing seed values.
// comparison hashes were generated by the murmur3 C library.
func TestMurmur3ChangingSeed(t *testing.T) {
	data := []byte{0x4E, 0xE3, 0x91, 0x00, 0x10, 0x8F, 0xFF}
	expected := []uint32{0x51d5aa73, 0x23b8cbd0, 0x6d2c10e9, 0x5deb2403,
		0xce0a0f7c, 0x5f52c1e1, 0xa4e33a96, 0x09228bdb,
		0x2def66bd, 0x4b0a2391, 0xc8864444, 0x593f1a60,
		0x15825b01, 0xb0f04256, 0xebf55421, 0x2aff1b0a}
	for i := 0; i < len(expected); i++ {
		h := New32Seed(uint32(i))
		h.Write(data)
		hash_bytes := h.Sum(nil)
		hash := (uint32(hash_bytes[0])<<24 | uint32(hash_bytes[1])<<16 |
			uint32(hash_bytes[2])<<8 | uint32(hash_bytes[3]))
		if hash != expected[i] {
			t.Fatal(i, "Seeding the hash failed, got", hash, "expected", expected[i])
		}
		hash = Hash(data, uint32(i))
		if hash != expected[i] {
			t.Fatal(i, "Seeding the hash failed, got", hash, "expected", expected[i])
		}
	}
}

// Tests Murmur3 to ensure it works with changing data.
// comparison hashes were generated by the murmur3 C library.
func TestMurmur3ChangingData(t *testing.T) {
	data := make([]byte, 133)
	expected := []uint32{0x108bb224, 0x6699a1c1, 0x4205ea7a, 0x5a635b39,
		0x4674c124, 0x500173ce, 0xfada1ef5, 0xda854d83,
		0xe9cc0f5b, 0x68517082, 0x5ba90f8d, 0xe316e97c,
		0x7cb4c206, 0xa9a0f739, 0x4728523a, 0x4462277f}
	for i := 0; i < 16; i++ {
		for j := 0; j < len(data); j++ {
			data[j] = byte((i + j) & 0xff)
		}
		h := New32Seed(0x1234ABCD)
		h.Write(data)
		hash_bytes := h.Sum(nil)
		hash := (uint32(hash_bytes[0])<<24 | uint32(hash_bytes[1])<<16 |
			uint32(hash_bytes[2])<<8 | uint32(hash_bytes[3]))
		if hash != expected[i] {
			t.Fatal(i, "Hash results failed, got", hash, "expected", expected[i])
		}
	}
}

// Tests Murmur3 to ensure it works with varying length data.
// comparison hashes were generated by the murmur3 C library.
func TestMurmur3ChangingDataLength(t *testing.T) {
	expected := []uint32{0x865366d4, 0x8cd4e3ce, 0xa5e2c3f5, 0x35c13d54,
		0x872425fc, 0x10df7f3f, 0xeb572c53, 0xdfae7ee9,
		0xcecc6c55, 0x9a8f6ae8, 0xd734d6b0, 0x6ddd724c,
		0x4dc113ab, 0xe8ee3178, 0xaecf904f, 0x2109de0c}
	for i := 0; i < 16; i++ {
		data := make([]byte, i)
		for j := 0; j < len(data); j++ {
			data[j] = byte((i + j) & 0xff)
		}
		h := New32Seed(0x7870AAFF)
		h.Write(data)
		hash_bytes := h.Sum(nil)
		hash := (uint32(hash_bytes[0])<<24 | uint32(hash_bytes[1])<<16 |
			uint32(hash_bytes[2])<<8 | uint32(hash_bytes[3]))
		if hash != expected[i] {
			t.Fatal(i, "Hash results failed, got", hash, "expected", expected[i])
		}
	}
}

// Benchmark the Murmur3 hash.Hash based implementation against small strings.
// Small in this case is 65 bytes.
func BenchmarkNewSmall(b *testing.B) {
	b.StopTimer()
	data := make([]byte, 65)
	b.SetBytes(int64(len(data)))
	for i := 0; i < len(data); i++ {
		data[i] = byte(i & 0xff)
	}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		h := New32Seed(0x7870AAFF)
		h.Write(data)
		h.Sum(nil)
	}
}

// Benchmark the Murmur3 hash.Hash based implementation againts larger strings.
// Large in this case is about 1024 byte strings.
func BenchmarkNewMedium(b *testing.B) {
	b.StopTimer()
	data := make([]byte, 1024)
	b.SetBytes(int64(len(data)))
	for i := 0; i < len(data); i++ {
		data[i] = byte(i & 0xff)
	}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		h := New32Seed(0x7870AAFF)
		h.Write(data)
		h.Sum(nil)
	}
}

// Benchmark the Murmur3 hash.Hash based implementation againts larger strings.
// Large in this case is about 16MB.
func BenchmarkNewLarge(b *testing.B) {
	b.StopTimer()
	data := make([]byte, 16*1024*1024)
	b.SetBytes(int64(len(data)))
	for i := 0; i < len(data); i++ {
		data[i] = byte(i & 0xff)
	}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		h := New32Seed(0x7870AAFF)
		h.Write(data)
		h.Sum(nil)
	}
}

// Benchmark the Murmur3 hashraw 32bit generation function against small data.
// Small in this case is 65 bytes.
func BenchmarkHashSmall(b *testing.B) {
	b.StopTimer()
	data := make([]byte, 65)
	b.SetBytes(int64(len(data)))
	for i := 0; i < len(data); i++ {
		data[i] = byte(i & 0xff)
	}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		Hash(data, 0x7870AAFF)
	}
}

// Benchmark the Murmur3 hashraw 32bit generation function against medium data.
// Medium in this case is 1024 bytes.
func BenchmarkHashMedium(b *testing.B) {
	b.StopTimer()
	data := make([]byte, 1024)
	b.SetBytes(int64(len(data)))
	for i := 0; i < len(data); i++ {
		data[i] = byte(i & 0xff)
	}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		Hash(data, 0x7870AAFF)
	}
}

// Benchmark the Murmur3 hashraw 32bit generation function against large data.
// Large in this case is 16MB bytes.
func BenchmarkHashLarge(b *testing.B) {
	b.StopTimer()
	data := make([]byte, 16*1024*1024)
	b.SetBytes(int64(len(data)))
	for i := 0; i < len(data); i++ {
		data[i] = byte(i & 0xff)
	}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		Hash(data, 0x7870AAFF)
	}
}
